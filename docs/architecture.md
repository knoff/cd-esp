# Архитектура прошивки (Universal Firmware)

**Версия:** 0.2 (Initial Core)
**Тип:** Monolithic Firmware w/ Role Switching

**Концепция:** One Binary to Rule Them All.
Мы используем **Единую Прошивку** для всех устройств в сети (Координатор, Помпа, Бойлер, Весы).
Роль устройства определяется при старте на основе конфигурации в **NVS** (`HU_TYPE_*`).

## Ключевые преимущества

- Одна точка сборки и тестирования.
- Единый механизм OTA-обновлений (A/B Partitioning).
- Возможность смены роли устройства "на лету" без программатора (через Console).

---

## 1. Структура проекта

Проект построен по модульному принципу.

```text
src/
├── main.cpp           # Точка входа, выбор режима, Boot loop protection
├── core/              # УРОВЕНЬ 1: Ядро (общее для всех)
│   ├── NVSConfig.cpp  # Хранилище состояния
│   ├── Network.cpp    # Транспорт (ESP-NOW / WiFi)
│   ├── OTA.cpp        # Логика A/B обновлений
│   └── Safety.cpp     # Watchdog, Panic Handler
├── hal/               # УРОВЕНЬ 0: Железо
│   ├── Board.h        # Pin Mapping
│   └── Peripherals.cpp
├── managers/          # УРОВЕНЬ 2: Функциональные блоки
│   ├── BaseManager.h  # Интерфейс
│   ├── GatewayMgr.cpp # Логика Координатора (Serial Bridge)
│   ├── PumpMgr.cpp    # Логика Помпы (PID Flow)
│   ├── HeaterMgr.cpp  # Логика Нагрева (PID Temp)
│   └── ...
└── console/           # Обработчик текстовых команд (CD-ADB)
```

Проект разделен на изолированные слои.

### Level 0: HAL (Hardware Abstraction)

- **SystemIO (`src/hal/SystemIO`):** - Единый диспетчер UART.
  - Разделяет поток на **Текстовые команды** (CLI) и **Бинарные фреймы** (Mesh).
  - Обеспечивает "чистый" вывод логов без разрыва строки ввода консоли.

### Level 1: Core (Ядро)

- **NVSConfig (`src/core/NVSConfig`):** Хранение `DeviceType`, `LogicalID` и калибровок.
- **Network (`src/core/Network`):** Обертка над ESP-NOW. Управляет очередями пакетов.
- **Console (`src/console/Console`):** - Реализация CD-ADB (Command Line Interface).
  - Паттерн **Command Registry**: модули регистрируют свои команды (`ping`, `status`) динамически.

### Level 2: Managers (Бизнес-логика)

Каждый тип устройства реализуется как класс-наследник `BaseManager`.

- **FactoryMgr:** Режим по умолчанию. Мигает светодиодом, ждет конфигурации.
- **GatewayMgr:** Работает на Координаторе. Мост `Serial <-> ESP-NOW`.
- **ActuatorMgr (TODO):** Управление моторами и PID.

## 2. Концепция "Менеджеров" (Hub Architecture)

Устройство (ESP32) выступает хостом для одного или нескольких функциональных блоков (**Managers**).

### Инициализация

1. При старте читается JSON-конфиг из NVS (или бинарная структура).
2. Пример конфига: `[{type: HEATER, pin: 12}, {type: VALVE, pin: 14}]`.
3. `main.cpp` создает экземпляры соответствующих классов.
4. В `loop()` вызывается метод `update()` для каждого активного менеджера.

### Преимущества

- Возможность создания "Комбинированных плат" (Hubs) без переписывания кода.
- Возможность смены назначения пинов без перекомпиляции (через NVS Injector).

---

## 3. Взаимодействие (Data Flow)

### Сценарий: CLI Команда

1. Пользователь вводит `ping` в Serial Monitor.
2. `SystemIO` накапливает байты в буфер. По `\n` вызывает коллбек `Console`.
3. `Console` ищет `ping` в реестре команд.
4. Вызывается лямбда, зарегистрированная в `GatewayMgr`.
5. Лямбда отправляет пакет в `Network`.

### Сценарий: Логирование

1. Любой модуль вызывает макрос `LOG_INF("Data: %d", val)`.
2. Макрос вызывает `SystemIO::log()`.
3. `SystemIO` стирает текущую строку ввода (`\r\033[K`), печатает лог, затем восстанавливает приглашение `>`.

## 4. Производственный процесс

### Этап 1: Flash (Чистая плата)

- Заливается `firmware_universal.bin`.
- NVS пуст.
- Устройство стартует в **Factory Mode**:
  - WiFi/ESP-NOW слушают команды конфигурации.
  - Доступен Serial Console.
  - LED мигает "Ожидание".

### Этап 2: Assembly (Сборка компонента)

- Сборщик подключает плату к периферии (например, к Помпе).
- С помощью "Config Stick" (или ПК) в NVS записывается:
  - `Device Type`: PUMP
  - `HW Revision`: 1.2
  - `Pin Map`: (Default for Pump Board v1.2)
- Устройство перезагружается и становится Помпой. Запускает Self-Test мотора.

### Этап 3: Integration (Установка в машину)

- RPi обнаруживает новое устройство.
- Проводит процедуру `Assign ID` (см. протокол).
- Устройство готово к работе.

---

## 4. OTA и Разделы

Используется схема **A/B Rollback**.

- **Partition Table:**
  - `nvs` (Config)
  - `otadata` (Boot select)
  - `app0` (Current)
  - `app1` (Next)
  - `coredump` (Для анализа крашей)

**Критерий успешности:** Работа без перезагрузки > X секунд ИЛИ успешная связь с RPi. Если критерий не выполнен — откат на предыдущий слот.
